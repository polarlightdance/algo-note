# 复杂度分析

1. 时间效率: 算法运行时间的长短 时间复杂度
2. 空间效率：算法占用内存空间的大小 空间复杂度
3. 递归
    - 递 程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”
    - 归 触发“终止条件”后，程序从最深层的递归函数开始逐层返回
    - 三要素
        - 终止条件：用于决定什么时候由“递”转“归”。
        - 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。
        - 返回结果：对应“归”，将当前递归层级的结果返回至上一层。
4. 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低
5. 如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归
6. 当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读
7. 时间复杂度分析特点
    - 时间复杂度能够有效评估算法效率
    - 时间复杂度的推算方法更简便
    - 时间复杂度也存在一定的局限性
8. 推算函数渐近上界
    - 忽略常数项
    - 省略所有系数
    - 循环嵌套时使用乘法

9. 空间复杂度 通常统计暂存数据、栈帧空间和输出数据三部分
10. 示例

``` c++
int func() {
    // 执行某些操作
    return 0;
}
/* 循环的空间复杂度为 O(1) */
void loop(int n) {
    for (int i = 0; i < n; i++) {
        func();
    }
}
/* 递归的空间复杂度为 O(n) */
void recur(int n) {
    if (n == 1) return;
    return recur(n - 1);
}

```
- loop 为 O(1)
- recur 为 O(n)